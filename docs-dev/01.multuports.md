# 01. multiports AI

Реализация мультипортового REST-контроллера в Spring 5 + Jersey 1.x

## Технологический стек
- Java 8
- Spring 5.2.8.RELEASE
- Jersey 1.19.4 (JAX-RS JSR 311)
- Tomcat (версии, совместимой с Java 8)
- Gradle 6.8.2 для сборки
- Log4j 1.2.14 для логирования

## Архитектурные решения
1. Конфигурация Tomcat
   Добавлен дополнительный HTTP Connector в server.xml:

```xml
<Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />
```

2. Аннотация @SpecialPort
   Маркерная аннотация для классов, требующих доступ только через специальный порт:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface SpecialPort {}
```

3. Динамическая конфигурация порта

Порт задается через переменную окружения SPECIAL_PORT:
- Если переменная не задана или некорректна — приложение не запускается
- Если значение -1 — функциональность отключена (все запросы блокируются)
- Любое другое число — номер порта для доступа

4. Проверка порта через ContainerRequestFilter\
   Реализован фильтр SpecialPortFilter, который:
- При инициализации собирает все классы с аннотацией @SpecialPort в HashSet
- Для каждого запроса проверяет, должен ли он обрабатываться на специальном порту
- Возвращает 404 Not Found при нарушении правил доступа

5. Интеграция Spring и Jersey

Использован SpringServlet для автоматической регистрации компонентов и провайдеров.

6. Сериализация JSON через JAXB
   Модели данных аннотированы JAXB аннотациями для преобразования в JSON и обратно.

### Ключевые компоненты

#### ContainerRequestFilter с загрузкой классов в HashSet

Составление списка компонент, аннотированных @SpecialPort.
Фильтр для проверки доступа к аннотированным ресурсам.

````java
package com.example.filter;

import com.example.annotation.SpecialPort;
import com.example.config.PortConfig;
import com.sun.jersey.api.model.ResourceMethod;
import com.sun.jersey.spi.container.ContainerRequest;
import com.sun.jersey.spi.container.ContainerRequestFilter;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.Provider;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Provider
@Component
public class SpecialPortFilter implements ContainerRequestFilter {

    private static final Logger logger = Logger.getLogger(SpecialPortFilter.class);

    @Context
    private HttpServletRequest httpRequest;

    @Autowired
    private ApplicationContext applicationContext;

    @Autowired
    private PortConfig portConfig;

    private Set<Class<?>> specialPortClasses = new HashSet<>();

    @PostConstruct
    public void init() {
        // Находим все бины с аннотацией @SpecialPort
        Map<String, Object> specialPortBeans = applicationContext.getBeansWithAnnotation(SpecialPort.class);

        for (Object bean : specialPortBeans.values()) {
            specialPortClasses.add(bean.getClass());
            logger.info("Registered special port class: " + bean.getClass().getName());
        }

        if (specialPortClasses.isEmpty()) {
            logger.info("No classes with @SpecialPort annotation found");
        }
    }

    @Override
    public ContainerRequest filter(ContainerRequest request) {
        try {
            // Получаем информацию о ресурсном методе
            Object resourceMethodObj = request.getProperties().get("com.sun.jersey.api.core.ResourceMethod");

            if (resourceMethodObj instanceof ResourceMethod) {
                ResourceMethod resourceMethod = (ResourceMethod) resourceMethodObj;
                Class<?> resourceClass = resourceMethod.getResource().getResourceClass();

                // Проверяем наличие класса в нашем HashSet
                if (specialPortClasses.contains(resourceClass)) {
                    checkPort();
                }
            }
        } catch (Exception e) {
            logger.warn("Failed to check special port annotation", e);
            // В случае ошибки пропускаем проверку
        }

        return request;
    }

    private void checkPort() {
        if (!portConfig.isSpecialPortEnabled()) {
            String message = "Special port functionality is disabled";
            logger.warn(message + ". Attempted access to: " + httpRequest.getRequestURI());
            throw new WebApplicationException(
                    Response.status(Response.Status.NOT_FOUND)
                            .entity(message)
                            .type("text/plain")
                            .build()
            );
        }

        int requestPort = httpRequest.getLocalPort();
        int requiredPort = portConfig.getSpecialPort();

        if (requestPort != requiredPort) {
            String message = "Resource available only on port " + requiredPort;
            logger.warn("Access attempt to port-restricted resource from port " +
                    requestPort + ". " + message);
            throw new WebApplicationException(
                    Response.status(Response.Status.NOT_FOUND)
                            .entity(message)
                            .type("text/plain")
                            .build()
            );
        }
    }
}
````
#### Аннотация SpecialPort.java

````java
package com.example.annotation;

import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface SpecialPort {
    // Маркерная аннотация без параметров
}
````

#### PortConfig.java

Загрузка и валидация настроек порта из переменных окружения.

````java
package com.example.config;

import org.springframework.context.annotation.Configuration;
import javax.annotation.PostConstruct;

@Configuration
public class PortConfig {
    
    private int specialPort;
    
    @PostConstruct
    public void init() {
        String portValue = System.getenv("SPECIAL_PORT");
        
        if (portValue == null || portValue.trim().isEmpty()) {
            throw new IllegalStateException("SPECIAL_PORT environment variable is required");
        }
        
        try {
            specialPort = Integer.parseInt(portValue.trim());
        } catch (NumberFormatException e) {
            throw new IllegalStateException("SPECIAL_PORT must be a valid integer or -1", e);
        }
        
        if (specialPort == -1) {
            System.out.println("Special port functionality is disabled (SPECIAL_PORT = -1)");
        } else {
            System.out.println("Special port configured to: " + specialPort);
        }
    }
    
    public int getSpecialPort() {
        return specialPort;
    }
    
    public boolean isSpecialPortEnabled() {
        return specialPort != -1;
    }
}
````
#### SpecialPortResource.java
Контроллер с аннотацией @SpecialPort, доступный только на специальном порту.
```java
package com.example.resource;

import com.example.annotation.SpecialPort;
import com.example.model.SimpleHello;
import org.springframework.stereotype.Component;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.xml.bind.JAXBElement;

@Component
@SpecialPort
@Path("/special")
public class SpecialPortResource {

    @POST
    @Path("data")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response processJson(JAXBElement<SimpleHello> data) {
        SimpleHello simpleHello = data.getValue();
        simpleHello.setName("Processed: " + simpleHello.getName());
        simpleHello.setMail(simpleHello.getMail() + ".processed");
        
        return Response.ok(data).build();
    }
    
    @GET
    @Path("info")
    @Produces(MediaType.TEXT_PLAIN)
    public String getInfo() {
        return "This is a special port endpoint";
    }
}
```

#### PublicResource.java
Обычный контроллер, доступный на всех портах.

Сборка и развертывание build.gradle
```gradle
plugins {
    id 'java'
    id 'war'
}

sourceCompatibility = '1.8'
targetCompatibility = '1.8'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.sun.jersey:jersey-bundle:1.19.4'
    implementation 'com.sun.jersey:jersey-spring:1.19.4'
    implementation 'org.springframework:spring-core:5.2.8.RELEASE'
    implementation 'org.springframework:spring-web:5.2.8.RELEASE'
    implementation 'org.springframework:spring-context:5.2.8.RELEASE'
    implementation 'org.springframework:spring-beans:5.2.8.RELEASE'
    implementation 'org.springframework:spring-aop:5.2.8.RELEASE'
    implementation 'org.springframework:spring-expression:5.2.8.RELEASE'
    implementation 'log4j:log4j:1.2.14'
    compileOnly 'javax.servlet:javax.servlet-api:3.1.0'
}

war {
    archiveFileName = 'jersey1-multi-port.war'
}
```

#### web.xml
Настроен SpringServlet и контекст Spring.

````xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <display-name>Jersey 1.x Multi-Port Application</display-name>

    <!-- Конфигурация Spring Context -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>
    
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.example.config.AppConfig</param-value>
    </context-param>
    
    <!-- Spring Context Listener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!-- Jersey Spring Servlet -->
    <servlet>
        <servlet-name>JerseySpringServlet</servlet-name>
        <servlet-class>com.sun.jersey.spi.spring.container.servlet.SpringServlet</servlet-class>
        <init-param>
            <param-name>com.sun.jersey.config.property.packages</param-name>
            <param-value>com.example</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>JerseySpringServlet</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
</web-app>
````

#### Запуск приложения
Установка переменной окружения
```bash
export SPECIAL_PORT=8081
```

#### Запуск Tomcat
Разместить WAR-файл в директории webapps и запустить Tomcat.

#### Проверка функциональности
Доступ к специальному эндпоинту на правильном порту
```bash
curl http://localhost:8081/special/data
```
Попытка доступа на неправильном порту
```bash
curl http://localhost:8080/special/data
# 404 Not Found
```

#### Доступ к публичному эндпоинту на любом порту
```bash
curl http://localhost:8080/public/info
curl http://localhost:8081/public/info
```

#### Отключение функциональности специального порта
```bash
export SPECIAL_PORT=-1
```

#### После перезапуска все запросы к /special вернут 404
Заключение
Реализована гибкая система разграничения доступа по портам с динамической конфигурацией.\
Приложение соответствует всем исходным требованиям и готово к развертыванию в Tomcat.

